1-1解释与编译的执行方式


1-2java与c++的不同：
1执行编译方式不同
2java纯面向对象，c++有点面向过程
3没有指针
4java自己就能管理程序运行内存（产生的垃圾），c++要自己写来管理

1-3 main函数的作用，参数string 数组的作用（在命令行情况下程序员与程序进行交互），
同一个类文件可以有多个main方法，但是以与类名与文件相同的为入口方法

1-4静态模块在类加载前就会执行，在主类main函数加一个静态模块，会在main执行前先执行此模块
静态块例子static {  //代码块
}

1-5java实例化一个类，（类对象的实例化）本质上是用类的构造方法来实例化，（有参或无参的构造方法）
所以教材书上那个圆的类才会那样：初始化时会有参数，
只是我们一般没有写构造方法，或者写的一个有参的构造方法

1-6初始化一个程序，或者叫初始化一个类对象
父类静态变量

2、父类静态代码块

3、子类静态变量

4、子类静态代码块

5、父类非静态变量

6、父类非静态代码块

7、父类构造器

8、子类非静态变量

9、子类非静态代码块

10、子类构造器

Java程序初始化一般遵循3个原则

静态对象（变量）先于非静态对象（变量）初始化。其中静态对象（变量）只初始化一次，而非静态对象（变量）可能会初始化很多次

父类优先于子类进行初始化

按照成员变量的定义顺序进行初始化。即使变量定义散布于方法之中，他们依然在任何方法（包括构造函数）被调用前先初始化

1-7变量的作用域，修饰符只能用来修饰成员变量，局部的不能修饰


1-8，java类的命名，注意有public的类，一定与文件同名，若没有public的，与文件里面随便一个类同名，
编译时，会给每一个类生成对应的.class文件


1-9构造函数：
1没有返回值，不是空返回值，就不用void
2参数可以是任意个
3只在类对象实例化时，即new一个对象时执行一次，且只会在new语句的时候自动调用
4构造函数不能被继承，（但是子类可以调用super方法使用构造方法),可以重载，即参数的变化.
5子类实例化要调用父类的构造方法，所以如果父类没有空参数的构造方法，
那么在子类的构造函数里要先super调用父类的构造方法，有的话就不用super，编译器会自动调用的
6子类父类都没有构造函数时编译器会自动加上无参的构造函数

1-10接口，接口可以继承接口，不需要实现方法，

1-11传参，基本类型传的是参数的复制，除此之外的都是传递引用，如函数调用，=

1-12clone方法：解决对象A同一个引用B，B的改变不影响A
使用步骤：1）实现Cloneable接口
 2）重写clone方法，public Object clone（）{
}
3)在重写的方法中添加try{Object o=（Object）super.clone();}catch（Exception e）{}
4)若类只有基本数据，浅复制：把新创建的对象调用方法Object a=new A();Object b=（Object）a.clone();

5）若还有其他非基本数据的属性变量，则try{Object o=（Object）super.clone();  o.s(s是一个类)=this.gets().clone}
catch（Exception e）{}

在调用其他类时，空间是如何变化的
传递引用是什么意思，引用，传递的同一个引用，一个改了会不会对另一个有影响


1-13java反射：Java反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。
对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。





（继承与实现，父类与接口，哪些能继承哪些能实现，接口继承接口是能多继承的）

接口实例化后调用实现类的方法，这个是什么原理

组合,接口只能public或者abstract修饰

看一下，App两种创建方式对象一不一样

用代码与bean配置区别


